You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:
coins = [1, 2, 5], amount = 11
return 3 (11 = 5 + 5 + 1)

Example 2:
coins = [2], amount = 3
return -1.

// 状态转移公式：dp[i]表示amount=i时最少需要多少个硬币
// dp[i] = min(dp[j] + 1)    0<=j<i，且j的取值要求i-j在硬币列表中
public class Solution {
	public int coinChange(int[] coins, int amount) {
		int[] dp = new int[amount + 1];
		dp[0] = 0;
		for (int i = 1; i <= amount; ++i) {
			int min = 999999;
			for (int coinIdx = 0; coinIdx < coins.length; ++coinIdx) {
				int j = i - coins[coinIdx];
				if (dp[j] != -1 && dp[j] + 1 < min) {
					min = dp[j] + 1;
				}
			}
			dp[i] = min == 999999 ? -1 : min;
		}
		return dp[amount];
	}
}